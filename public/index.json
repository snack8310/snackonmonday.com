[{"categories":null,"content":"架构设计中的扩展性在项目开发中，大家一定遇到过系统卡顿的场景，当我们想要解决系统瓶颈时，究竟该如何选择？ 欢迎观看系统架构设计系列内容，今天我们聊一下系统架构设计中的扩展性。 今天我们讲一个梦想书城的线上书店的故事。梦想书城有两个主要功能：查询、下单。 梦想书城初级版\" 梦想书城初级版 书城刚开业。里面只有1款书，库存10本。很快就吸引到50个用户访问，在10天的时间里卖完了全部10本书。书城收到钱，支付了服务器和网络的费用，可以继续扩大规模。现在有10款书，每款库存100本，共计1000本书。也很快，用户注册数量超过了2000。现在每天都有1000个用户访问，购买约100本书，按照有效销售的时间10小时计算，系统至少要求满足100个用户/时的访问，10本书/时的销售的吞吐量。吞吐量是用来衡量系统能力的重要指标。 如果服务器故障、断电等问题，每小时的故障就意味着10本书的损失。行业里流行的方案是使用云服务器，类似阿里云，亚马逊云等，这些云服务器可以帮助规避这些问题，专注在业务中。 梦想书城的工程师在阿里云上买了一台配置是2核4GB内存的服务器，把梦想书城运转了起来。1000本书又很快的卖光了，真是令人开心。 梦想书城高级版\" 梦想书城高级版 继续扩大规模，现在系统里有100款，每款500本，累计库存50000本。注册的用户数量也超过了10000人。原本预计，日销量能够到达1000本。但实际上只卖不到500本。 很快大量的用户反馈出现了：“系统查询太慢了，想要的书根本找不到”，“我选到了书，但是下单的时候需要等待”。 图片 系统崩溃了。 梦想书城的工程师想要尽快解决这个问题。考虑到书城的成长，为了支撑到日销2000本的能力，选择买一台更好的8核16GB内存的服务器，这种方案是否可行？工程师们做了深度的讨论。 最显而易见的优点：不需要改变任何代码逻辑。只需要升级硬件即可。 但这个方案会有潜在的问题。## 方案潜在的问题 服务器故障。如果只有一台服务器，故障了用户就无法访问。我们仍然担心这一台服务器出现故障。就算阿里云可以快速速诊断并且在3分钟内修复给用户使用，这其实仍然是一个很大的事故，造成了3/365(天)/24(时)/60(分)故障率，系统可用性降到99.9994%。 硬件限制。这是个致命的问题。预计在3个月后，梦想书店的用户和销量都能扩大10倍，未来也许更多，就像京东，当当的书城，每天可能是10万的订单。可是在阿里云的服务器里，找不到一个80核160GB的服务器，更不要说持续增长的未来。过去有一个词叫摩尔定律，每一年半，硬件性能提升一倍。虽然现在摩尔定律已经不那么准确，但显然是跟不上业务规模的成长。 有没有其他的方案呢。 梦想书城也可以选择买4台服务器，期待4倍的服务能力去解决这个问题。而且看上去能够规避升级硬件的问题。 方案最大的优点：突破硬件的限制，可以支撑40倍，400倍或更大的需求。 这个方案会有什么问题？ 系统故障。如果一台服务器发生了故障，这时候有1/4的人只能看到画面上尴尬的写着“404”，无论怎么刷新，都看不到书店任何内容。我们不能接受这种状况，实际上当时另外3台服务器都正常运行，必须要让用户访问到正常运转的服务器上，屏蔽错误的服务器。能完成这样功能的组件，就是负载均衡（load balance），它们也是一个机器，被设置在服务器前，当后端服务器故障，可以把用户访问指向可用的服务器上。当然这里有很多策略，这里暂不展开。 图片 数据不一致。现在有个用户把一款书最后一本买走了。他看到的库存从1变成了0。这是另一个用户登录在另一台服务器上，看到的库存还有1本。他是否能买到书？显然是不能的，工程师们要避免这种情况。这种数据不一致的情况，称为数据一致性（data consistency）问题。一种办法是，当有一个服务器卖书的时候，通知其他服务器不要卖书，但这是不切实际的。梦想书城的工程师们被迫优化新的代码，增加了非常多校准数据和同步数据的功能。 图片 性能下降。增加校验数据同步数据功能后，原本一个下单的动作，只要大概100ms，现在时间增加了一倍，200ms才能完成。这是因为原本系统内部的逻辑，变成服务器之间信息传递，增加了服务通信成本（network communication）。这些服务器之间的通讯，通常的方案是远程过程调用（RPC），会产生大量的网络IO访问。网络信息传递的速度，遥远大于系统内部的调用速度。 系统复杂度呈现指数级的膨胀。从服务器间的交互，前端和服务器，到服务器和数据库等等的交互，还需要增加很多工具组件，就像监控日志，系统检测，链路追踪，限流限速等等的需求。 图片 这些方案，实际上是系统设计领域里的重要概念：扩展性。如何选择和应对业务扩展需求，是互联网领域最重要的设计考量，甚至没有之一。 图片 更多的服务器的方案，提供更多请求响应的能力，称之为”水平扩展“（scale out）。买更好的服务器，提供更快，更好的单次响应性能，称之为”垂直扩展“（scale up）。 扩展性的本质，是基于某一垂直能力上的水平提升。很多场景，仍然可以通过垂直扩展解决问题，但这是有上限的，水平提升是几乎无上限的。 当面临需要扩展的需求时，具体选择哪种方案更合适呢？这里没有标准答案，都要结合实际情况考虑。 一般考虑方案，根据业务类型，做倾向性的选择。 对于梦想书城的查询功能的性能瓶颈，优先考虑垂直扩展。想象一下，好比在书城里扩建一个更大的展厅，摆放更多的书展示给用户。这种查询类动作，称为读操作，显著特征是很多人会共用一个查询结果，重复率较高。这种业务类型下，垂直扩展会更多一些。常见的解决方案是利用一些CDN，缓存，使用更多静态文件或者内存组策略。 对于梦想书城里下单等待的功能，优先考虑水平扩展。想象一下超市收银台的场景，把20个收银台增加到40个，就可以让同时结账的人数增加一倍。这种用户改变数据为目的的动作，称为写操作，显著特征是互相之间干扰较少，独立完成数据库的更新。写操作比较多的业务类型下，水平扩展会更多一些。常见的解决方案是增加线程，服务器，批量合并等等。 图片 另外，在一个项目的不同阶段来说，也会有些选择的倾向性。 通常来说，在项目初期出现性能瓶颈，会优先考虑垂直提升。这个阶段如何响应业务需求，推进业务发展，远比考虑负载均衡，考虑异地灾备等等重要的多。通过垂直提升，减少不必要的设计复杂度，让大家的焦点停留在业务上，避免精力分散。 在项目成长后，出现的性能问题，优先水平扩展为主。很多项目会经历业务的爆发式成长，必须要通过水平扩展来应对增长的规模。这个阶段也会衍生出很多类似服务治理，监控，限流，灾备等多种提高系统健壮性，可靠性为目标的功能。必要的场景下考虑更换底层技术方案，以解决性能瓶颈。 图片 最终，梦想书城的工程师们选择提升了2倍的机器性能，增加缓存集群，应对用户查询诉求；增加2台服务器，防止单点故障，并对应对可预期的下单量增长。 梦想书城这个案例给了我们一些启示。无论是什么场景，到哪个阶段，考虑扩展性的时候，权衡总是需要的。就像是分布式领域里著名的CAP定理，面对的性能和数据一致问题，项目过程中也总会面对在有限的时间内，适配未来更灵活还是现在更快等等问题。权衡能力的细微之处，也是一个架构设计好坏的差异，也是系统设计的目的。 这期系统扩展性的设计就说到这里，如果有什么疑问和建议，请随时留言给我，欢迎大家一起讨论。 ","date":"2021-12-27","objectID":"/scale_in_architecture/:1:0","series":null,"tags":null,"title":"系统设计中的扩展性","uri":"/scale_in_architecture/#架构设计中的扩展性 class=headerLink"},{"categories":null,"content":"大家好，今天我们聊一下什么是API，以及如何设计一个好的API。 ","date":"2021-12-27","objectID":"/what_is_a_good_api/:0:0","series":null,"tags":null,"title":"定义一个好的API","uri":"/what_is_a_good_api/#"},{"categories":null,"content":"什么是API？举个现实场景的例子，我们去餐厅吃饭，通过菜单了解到餐厅提供的美食清单，指定选择菜单上的菜品，得到我们想要的餐食。虽然我们并不了解餐食是如何做出来的，仍然可以通过这一方式获得想要的结果。这个过程，换成程序语言，就是一个调用API，获得结果的过程。 在一个编程的角度来说，API，Application Programming Interface，是预先定义好的一个应用程序接口。可以根据约定，提供外部系统或人员需要的应用程序内部的数据，而又不需要了解程序内部的实现过程或细节。 举个例子，梦想书城的项目开发中有一个动作，根据作者姓名得到作者信息。那么这个动作应该提供一个API，getAuthors，提供返回的作者们的名称，包括可能找不到作者的场景，提供一个查找不到的响应标识。 常见的API有很多，Web标准协议Restful API，Windows的动态链接库，Linux的POSIX等。一个API通常由方法名，参数和返回值组成，这和编程开发中的函数很像，明显的区别是是否屏蔽内部实现。 ​ ","date":"2021-12-27","objectID":"/what_is_a_good_api/:0:1","series":null,"tags":null,"title":"定义一个好的API","uri":"/what_is_a_good_api/#什么是api class=headerLink"},{"categories":null,"content":"什么是好的API？首先我们要明确，API是为了让外部系统调用的。那么最重要的一点，就是可以清楚的告诉外部系统，能得到什么，不能得到什么。判断一个API描述是否清楚，可以采用采用一个小技巧，遮挡住参数和返回值，能否根据方法名称猜到返回值和参数内容。 方法名称中要明确返回值的边界。根据刚才的梦想书城的例子getAuthors，这个API的返回结果应该有且只有一种，作者信息，仅限于作者这个模型特征的信息数据。API的数据提供方也限制在作者这个模型领域内。有一种情况，实际开发中经常会出现，调用方想要在返回结果中增加作者所在的作家协会，假如API中增加了类似的信息，那这个就不是一个合适的API定义。合适的办法是开发另外的API接口，并明确的指出返回值范围包括所属作家协会，例如getAuthorsWithOrgs。我们需要明确地返回值边界，确保getAuthors的所有使用方没有歧义。 方法参数要跟方法主体匹配。还是getAuthors的例子，根据这个名称，我们判断这个方法可以设置的参数大概是，作者姓名，作者年龄，性别等等，例如getAuthors（name），很多场合也可以用author.get（name）的方法，这两个含义相同，参数要限制在作者这个模型主体之内。如果有个场景是根据书名返回作者名称，那么强烈建议修改方法名称为getAuthorsByBookname，这种情况下，外部系统和开发者都很容易判定参数应该只有Bookname一种。 避免增加附加参数。很多“祖传”代码中常见的问题，例如getAuthors方法中，增加一个调用方的参数，并且通常能看到实现中有一段hardcode，写着如果是某个调用方，有些逻辑是特别的。这种特别的附加参数，对于方法描述是毫无意义的，但是对于外部系统调用方来说有很困惑。另一种，根据不同的附加参数，会执行不同的逻辑。假设现在有个方法setAuthor（author，org），要添加一个作者，如果作者有作家协会，同时更新所属协会。这种情况下，还是强烈建议修改名称，在方法描述中，体现出这个附加参数的含义。 ","date":"2021-12-27","objectID":"/what_is_a_good_api/:0:2","series":null,"tags":null,"title":"定义一个好的API","uri":"/what_is_a_good_api/#什么是好的api class=headerLink"},{"categories":null,"content":"清晰的定义一个API，对系统内部也会有很多好处。 降低IO开销。很多时候，一个API调用会对多个微服务模块进行调用，数据组装。这些IO调用的成本非常的昂贵。明确的API定义，能让外部系统调用方选择最准确的方法，避免无效的时间浪费。特别是现在互联网行业下，动辄数十万次的调用，累计起来的IO消耗非常大。 降低API重构风险。只做一件事，明确的API边界，意味着最小力度的访问关联的微服务，降低由于其他业务变化，引起的API实现逻辑变更。系统开发中，“蝴蝶效应”是非常明显的，经常会发生A系统的功能变化，莫名引起E系统的故障，一条链路上的B，C，D系统都需要跟着排查的事情。清晰的API边界能有效减少其他业务的耦合度，降低重构风险。 减少未来功能扩大化的风险。你永远不知道未来会发生什么，防止未来的同事，甚至自己，在这个方法中添加超出方法边界的功能，是让外部系统调用清晰以外最重要的一个价值。尽可能的做到参数准确定义，对潜在的风险给出明确的拒绝的含义。例如，getAuthorsByBookname，getAuthorsByBookId，要比GetAuthorsByBook，要好。getMaleAuthorsWithOrgs也要比getAuthorsWithOrgs（male）好很多，可以想象的未来getAuthorsWithOrgs的参数会增加到male，age，甚至create time这种非业务含义逻辑。 ","date":"2021-12-27","objectID":"/what_is_a_good_api/:0:3","series":null,"tags":null,"title":"定义一个好的API","uri":"/what_is_a_good_api/#清晰的定义一个api对系统内部也会有很多好处 class=headerLink"},{"categories":null,"content":"讲了最重要的方法定义，还有一些帮助我们建立好的API设计的实践经验。 明确的参数校验错误信息，减少不必要的参数校验。有些校验是必须的，例如非空判定，例如更新数据时的类型判断，我们要提供明确的错误信息，告知哪个字段为空，不是让外部系统猜测。但有些并不必要，可以减少API复杂度。例如查询参数过长，如果不会引起数据库异常，这个就是外部系统调用方的问题，结果只是查找不到，他们会自己发现问题。同样的，一个字符串的数值，也不需要判定是否传入一个整数，抛出奇怪的类型转换错误。尽量避免返回一个通用错误，例如，未知错误。 减少同时更新并查询的定义。这点在RestfulAPI上经常看到，例如想要查询作者信息，通过Get语义获得Authors，要比Post语义中返回Authors要好很多，并不仅仅是传递参数位置和大小的原因，使用Post语义容易产生更新数据的歧义。很多方法API定义中，setAuthors 或者 saveAuthors，会经常性同时返回一个结果，这样会有一定的隐患。例如我们想要增加缓存，缓存最佳实践中，建议更新的场景删除缓存，获取的场景设置缓存，这种同时返回结果，在并发的场景下，会产生脏数据，也会给使用方带来困惑。 明确单条和多条的查询结果使用不同的定义，多条返回结果中使用分页。例如getAuthorById，getAuthors。对于外部系统使用方，也容易判定如何使用，降低系统错误。强烈建议除非明确的返回数量含义，或者基于共识以外，要使用分页返回数据，并且给出的当前是第几页或者第几个游标。比如我们限定用户的收货地址，不超过5个，那么返回地址的API中，可以不用分页。但如果我们返回当前热销的书籍，尽量使用带分页的返回结果。也许后面的场景中，会出现最热销的100本的要求。 API调用量很大的场合，要分片，并且有结束标识。很多时候，会需要返回大量的数据，例如调用查询最近6个月的交易情况，也许这个动作会有上百kb的数据响应包。我们需要依次把分片的数据包发送给外部接收方，并且告知最后一个数据包，进行合并。当然同样的操作，也可以在分页定义数据中完成，但这增加了网络IO的调用次数，并增加了业务的复杂度。 增加缓存或增加限流限速措施。这两个放在一起的原因，是他们都是为了解决系统的可用性。一个例子是系统的评论系统，大部分场景，你并不关心过去几秒钟发生的评论信息，或者用户更新了头像，其他人默认看到的是昨天的头像，并不会造成什么问题。另外一些场景，外部系统的调用方，突然地大规模的调用API，可能会引起系统故障，那么就要增加限流措施等降级措施。比如梦想书城的供应商系统突然上传全部的库存书籍，这可能是不合理的，需要做一定的限制。 提供版本号。这一般发生在服务方，在外部系统调用方不可控的场景下。例如移动终端APP使用的后端服务，或者供应商使用的数据传输接口。这种一经发布，不可修改的业务场景，使用版本管理API定义是非常有效的API设计。 一个好的API定义，就是一种对功能范围的明确约定。对外部系统来说，约定的范围能避免业务分期；对内部服务来说，明确地范围能有效的降低未来的功能变更的风险。 如果你对上述的内容有任何的想法和建议，欢迎留言给我。非常感谢。 ","date":"2021-12-27","objectID":"/what_is_a_good_api/:0:4","series":null,"tags":null,"title":"定义一个好的API","uri":"/what_is_a_good_api/#讲了最重要的方法定义还有一些帮助我们建立好的api设计的实践经验 class=headerLink"},{"categories":null,"content":" Theme Documentation - Basics Discover what the Hugo - DoIt theme is all about and the core-concepts behind it. 阅读全文 Theme Documentation - Content Find out how to create and organize your content quickly and intuitively in DoIt theme. 阅读全文 Theme Documentation - Extended Shortcodes DoIt theme provides multiple shortcodes on top of built-in ones in Hugo. 阅读全文 ","date":"2021-11-01","objectID":"/showcase/:0:0","series":null,"tags":null,"title":"Showcase","uri":"/showcase/#"},{"categories":null,"content":"记录技术性文章 学习如何把文章分类展示这里 ","date":"2019-08-02","objectID":"/tech/:0:0","series":null,"tags":null,"title":"技术","uri":"/tech/#"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]